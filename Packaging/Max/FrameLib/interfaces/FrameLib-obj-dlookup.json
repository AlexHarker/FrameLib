{
    "fl.poltocar~": {
        "digest": "Converts from polar values at the inputs to cartesian values at the outputs."
    },
    "fl.spatial~": {
        "digest": "Generates multiplication factors for a number of speakers from an input coordinate triple."
    },
    "fl.cartopol~": {
        "digest": "Converts from cartesian values at the inputs to polar values at the outputs."
    },
    "fl.unpack~": {
        "digest": "Unpacks multistream input into individual streams."
    },
    "fl.streamid~": {
        "digest": "Outputs the stream id for each stream in a multistream connection."
    },
    "fl.pack~": {
        "digest": "Packs multiple frame streams into a multistream output."
    },
    "fl.dispatch~": {
        "digest": "Dispatches multiple inputs dynamically to multiple outputs."
    },
    "fl.route~": {
        "digest": "Routes the input to one of a number of outputs."
    },
    "fl.select~": {
        "digest": "Selects output from a number of inputs."
    },
    "fl.timedelta~": {
        "digest": "Calculates the time interval between consecutive incoming frames."
    },
    "fl.timer~": {
        "digest": "Calculates the time elapsed between the each trigger input and the previous reset."
    },
    "fl.now~": {
        "digest": "Outputs the current time."
    },
    "fl.ticks~": {
        "digest": "Counts incoming frames."
    },
    "fl.sort~": {
        "digest": "Sorts an input frame into ascending or descending order."
    },
    "fl.shift~": {
        "digest": "Shifts samples within a frame."
    },
    "fl.accumpos~": {
        "digest": "Finds the index where the cumulative sum reaches a specified percentage of its total."
    },
    "fl.framemin~": {
        "digest": "Calculates the minimum value of the input frame."
    },
    "fl.centroid~": {
        "digest": "Calculates the centroid of the input frame."
    },
    "fl.medianfilter~": {
        "digest": "Applies a median or other specified percentiled filter to the input."
    },
    "fl.percentile~": {
        "digest": "Calculates a specified percentile of the input frame (by default the 50th or median)."
    },
    "fl.kurtosis~": {
        "digest": "Calculates the kurtosis of the input frame."
    },
    "fl.maxpos~": {
        "digest": "Calculates the index of the maximum value of the input frame."
    },
    "fl.nonzero~": {
        "digest": "Outputs the indices of input samples that are non-zero."
    },
    "fl.stddev~": {
        "digest": "Calculates the standard deviation of the input frame."
    },
    "fl.flatness~": {
        "digest": "Calculates the flatness (as a ratio) of the input frame."
    },
    "fl.skewness~": {
        "digest": "Calculates the skewness of the input frame."
    },
    "fl.kernelsmooth~": {
        "digest": "Smooth an input based on a provided smoothing kernel."
    },
    "fl.join~": {
        "digest": "Concatenates all input frames into a single output frame."
    },
    "fl.length~": {
        "digest": "Calculates the length of the input frame."
    },
    "fl.mean~": {
        "digest": "Calculates the mean of the input frame."
    },
    "fl.framemax~": {
        "digest": "Calculates the maximum value of the input frame."
    },
    "fl.rms~": {
        "digest": "Calculates the rms of the input frame."
    },
    "fl.pad~": {
        "digest": "Pads the input frame with a repeated specified value."
    },
    "fl.reverse~": {
        "digest": "Computes the reverse of the input frame."
    },
    "fl.pattern~": {
        "digest": "Step through a frame of values (or pattern) one at a time."
    },
    "fl.sum~": {
        "digest": "Calculates the sum of the input frame."
    },
    "fl.nanfilter~": {
        "digest": "Filter NaNs from the input either by replacing or by removing them."
    },
    "fl.geomean~": {
        "digest": "Calculates the geometric mean of the input frame."
    },
    "fl.split~": {
        "digest": "Splits input frames into two frames, given a specified split point."
    },
    "fl.subframe~": {
        "digest": "Output a specified segment of an input frame."
    },
    "fl.minpos~": {
        "digest": "Calculates the index of the minimum value of the input frame."
    },
    "fl.product~": {
        "digest": "Calculates the product of the input frame."
    },
    "fl.crest~": {
        "digest": "Calculates the crest factor of the input frame."
    },
    "fl.chop~": {
        "digest": "Chops input frames into equally sized output frames of a specified size."
    },
    "fl.peaks~": {
        "digest": "Finds peaks in the input frame."
    },
    "fl.prioritise~": {
        "digest": "Apply a fixed priority ranking to synchronous input frames."
    },
    "fl.spread~": {
        "digest": "Calculates the spread of the input frame."
    },
    "fl.complex.minus~": {
        "digest": "Subtracts complex values in the right input frame pair from those in the left pair."
    },
    "fl.complex.times~": {
        "digest": "Multiplies complex values in the two pairs of input frames."
    },
    "fl.complex.pow~": {
        "digest": "Raises left operand values to the power of right operand values (both complex)."
    },
    "fl.complex.divide~": {
        "digest": "Divides complex values in the left pair of input frames by those in the right pair."
    },
    "fl.complex.plus~": {
        "digest": "Adds complex values in the two pairs of input frames."
    },
    "fl.read~": {
        "digest": "Reads from a specified host buffer given an input frame of positions."
    },
    "fl.info~": {
        "digest": "Outputs the sample rate, number of channels and length of a specified buffer."
    },
    "fl.exp2~": {
        "digest": "Calculates the exponent base 2 (2^x) of each value in the input frame."
    },
    "fl.asinh~": {
        "digest": "Calculates the hyperbolic arcsine of each value in the input frame."
    },
    "fl.log~": {
        "digest": "Calculates the logarithm base e of each value in the input frame."
    },
    "fl.erf~": {
        "digest": "Calculates the error function of each value in the input frame."
    },
    "fl.exp~": {
        "digest": "Calculates the exponent base e (e^x) of each value in the input frame."
    },
    "fl.sin~": {
        "digest": "Calculates the sine (for arguments in radians) of each value in the input frame."
    },
    "fl.log2~": {
        "digest": "Calculates the logarithm base 2 of each value in the input frame."
    },
    "fl.asin~": {
        "digest": "Calculates the arcsine (in radians) of each value in the input frame."
    },
    "fl.acos~": {
        "digest": "Calculates the arccosine (in radians) of each value in the input frame."
    },
    "fl.cos~": {
        "digest": "Calculates the cosine (for arguments in radians) of each value in the input frame."
    },
    "fl.sinh~": {
        "digest": "Calculates the hyperbolic sine of each value in the input frame."
    },
    "fl.floor~": {
        "digest": "Calculates the floor function of each value in the input frame."
    },
    "fl.trunc~": {
        "digest": "Calculates the truncated value of each value in the input frame."
    },
    "fl.log10~": {
        "digest": "Calculates the logarithm base 10 of each value in the input frame."
    },
    "fl.atanh~": {
        "digest": "Calculates the hyperbolic arctangent of each value in the input frame."
    },
    "fl.sqrt~": {
        "digest": "Calculates the square root of each value in the input frame."
    },
    "fl.acosh~": {
        "digest": "Calculates the hyperbolic arccosine of each value in the input frame."
    },
    "fl.tan~": {
        "digest": "Calculates the tangent (for arguments in radians) of each value in the input frame."
    },
    "fl.not~": {
        "digest": "Calculates the logical not of each value in the input frame."
    },
    "fl.atan~": {
        "digest": "Calculates the arctangent (in radians) of each value in the input frame."
    },
    "fl.tanh~": {
        "digest": "Calculates the hyperbolic tangent of each value in the input frame."
    },
    "fl.erfc~": {
        "digest": "Calculates the complimentary error function of each value in the input frame."
    },
    "fl.abs~": {
        "digest": "Calculates the absolute value of each value in the input frame."
    },
    "fl.round~": {
        "digest": "Calculates the rounded value of each value in the input frame."
    },
    "fl.cbrt~": {
        "digest": "Calculates the cube root of each value in the input frame."
    },
    "fl.cosh~": {
        "digest": "Calculates the hyperbolic cosine of each value in the input frame."
    },
    "fl.ceil~": {
        "digest": "Calculates the ceiling function of each value in the input frame."
    },
    "fl.copysign~": {
        "digest": "Copys the signs of the right input frame onto the magnitudes of the left input frame."
    },
    "fl.greaterthaneq~": {
        "digest": "Compares input frames using a greater than or equal to operation (returns 1 or 0)."
    },
    "fl.greaterthan~": {
        "digest": "Compares input frames using a greater than operation (returns 1 or 0)."
    },
    "fl.or~": {
        "digest": "Calculates the logical or of the left and right input frame values."
    },
    "fl.and~": {
        "digest": "Calculates the logical and of the left and right input frame values."
    },
    "fl.times~": {
        "digest": "Multiplies values in the two input frames."
    },
    "fl.divide~": {
        "digest": "Divides the left input frame values by the right input frame values."
    },
    "fl.minus~": {
        "digest": "Subtracts the right input frame values from the left input frame values."
    },
    "fl.pow~": {
        "digest": "Raises left input frame values to the power of right input frame values."
    },
    "fl.atan2~": {
        "digest": "Calculates the arctangent using two arguments (left operand is y, right operand is x)."
    },
    "fl.notequals~": {
        "digest": "Compares frame values for inequality (returns 1 or 0)."
    },
    "fl.lessthaneq~": {
        "digest": "Compares input frames using a less than or equal to operation (returns 1 or 0)."
    },
    "fl.max~": {
        "digest": "Calculates the maximums of pairs of values in the two input frames."
    },
    "fl.plus~": {
        "digest": "Adds values in the two input frames."
    },
    "fl.modulo~": {
        "digest": "Calculates the left input frame values modulo the right input frame values."
    },
    "fl.lessthan~": {
        "digest": "Compares input frames using a less than operation (returns 1 or 0)."
    },
    "fl.diff~": {
        "digest": "Calculates the absolute differences between values in the two input frames."
    },
    "fl.equals~": {
        "digest": "Compares frame values for equality (returns 1 or 0)."
    },
    "fl.hypot~": {
        "digest": "Calculates the length of a hypotenuse given the two operands as the other lengths."
    },
    "fl.min~": {
        "digest": "Calculates the minimums of pairs of values in the two input frames."
    },
    "fl.uniform~": {
        "digest": "Generates frames in which all values are identical."
    },
    "fl.random~": {
        "digest": "Generates linearly distributed random values in the range [0-1]."
    },
    "fl.gaussian~": {
        "digest": "Generates frames of normally distributed random values."
    },
    "fl.makewindow~": {
        "digest": "Generates a specified window function across each output frame."
    },
    "fl.ramp~": {
        "digest": "Generates a linear ramp across each output frame."
    },
    "fl.tomax~": {
        "digest": "Turn frames into host messages or control signals."
    },
    "fl.frommax~": {
        "digest": "Turn messages or control signals from the host into frames."
    },
    "fl.sink~": {
        "digest": "Outputs frames to the host environment as audio by overlap-adding into an output buffer."
    },
    "fl.trace~": {
        "digest": "Outputs values from the input as audio, continuing the last value till a new frame arrives."
    },
    "fl.source~": {
        "digest": "Captures audio from the host environment and outputs the most recent values as frames."
    },
    "fl.convolve~": {
        "digest": "Convolves two inputs (either real or complex)."
    },
    "fl.multitaper~": {
        "digest": "Calculates a multitaper power (or amplitude) spectrum from a real input."
    },
    "fl.firphase~": {
        "digest": "Transform FIR coefficients to preserve the amplitude spectrum but alter the phase."
    },
    "fl.correlate~": {
        "digest": "Correlates two inputs (either real or complex)."
    },
    "fl.fft~": {
        "digest": "Calculate the real or complex Fast Fourier Transform of the input(s)."
    },
    "fl.ifft~": {
        "digest": "Calculate the real or complex inverse Fast Fourier Transform of the inputs (real and imaginary)."
    },
    "fl.window~": {
        "digest": "Multiplies the input frame by a specified window."
    },
    "fl.store~": {
        "digest": "Stores frames remotely for later recall."
    },
    "fl.register~": {
        "digest": "Store and recall frames locally."
    },
    "fl.recall~": {
        "digest": "Recall a remotely stored frame for use."
    },
    "fl.timemedian~": {
        "digest": "Calculates the specified percentile per sample over the most recent frames."
    },
    "fl.framedelta~": {
        "digest": "Outputs the deltas between consecutive frames."
    },
    "fl.lag~": {
        "digest": "Delay vector type input by a whole number of frames."
    },
    "fl.timemean~": {
        "digest": "Calculates the mean per sample over the most recent frames."
    },
    "fl.timestddev~": {
        "digest": "Calculates the standard deviation per sample over the most recent frames."
    },
    "fl.movingaverage~": {
        "digest": "Calculates per sample moving averages and standard deviations."
    },
    "fl.perblock~": {
        "digest": "Schedules one frame at the start of each host audio block."
    },
    "fl.once~": {
        "digest": "Schedules a single frame at the begining of time that lasts forever."
    },
    "fl.audiotrigger~": {
        "digest": "Schedules frames based on non-zero audio input."
    },
    "fl.interval~": {
        "digest": "Schedules frames at regular intervals set by the interval parameter."
    },
    "fl.chain~": {
        "digest": "Schedules frames in the future at times specified times in the input frame."
    },
    "fl.complex.sinh~": {
        "digest": "Calculates the hyperbolic sine of each complex value at the inputs."
    },
    "fl.complex.cos~": {
        "digest": "Calculates the cosine of each complex value at the inputs."
    },
    "fl.complex.sin~": {
        "digest": "Calculates the sine of each complex value at the inputs."
    },
    "fl.complex.exp~": {
        "digest": "Calculates the exponent base e (e^x) of each complex value at the inputs."
    },
    "fl.complex.log~": {
        "digest": "Calculates the logarithm base e of each complex value at the inputs."
    },
    "fl.complex.cosh~": {
        "digest": "Calculates the hyperbolic cosine of each complex value at the inputs."
    },
    "fl.complex.log10~": {
        "digest": "Calculates the logarithm base 10 of each complex value at the inputs."
    },
    "fl.complex.tanh~": {
        "digest": "Calculates the hyperbolic tangent of each complex value at the inputs."
    },
    "fl.complex.tan~": {
        "digest": "Calculates the tangent of each complex value at the inputs."
    },
    "fl.complex.conj~": {
        "digest": "Calculates the complex conjugate of each complex value at the inputs."
    },
    "fl.complex.sqrt~": {
        "digest": "Calculates the square root of each complex value at the inputs."
    },
    "fl.wrap~": {
        "digest": "Wraps the incoming frame into the range delimited by the two parameters."
    },
    "fl.fold~": {
        "digest": "Folds the incoming frame into the range delimited by the two parameters."
    },
    "fl.clip~": {
        "digest": "Clips the incoming frame to the range delimited by the two parameters."
    },
    "fl.lookup~": {
        "digest": "Lookup values from one input using a table provided at another."
    },
    "fl.convert~": {
        "digest": "Converts the input vector according to a specified conversion."
    },
    "fl.constant~": {
        "digest": "Outputs a specified constant."
    },
    "fl.map~": {
        "digest": "Maps values from input to output via a specified scaling."
    },
    "fl.samplerate~": {
        "digest": "Convert or output values based on the sample rate."
    },
    "fl.onepolezero~": {
        "digest": "Applies a one-pole with one-zero filter to the input."
    },
    "fl.biquad~": {
        "digest": "Applies a biquad filter to the input."
    },
    "fl.biquadcoeff~": {
        "digest": "Calculates biquad filter coefficients."
    },
    "fl.svf~": {
        "digest": "Applies a state variable filter to the input."
    },
    "fl.onepole~": {
        "digest": "Applies  a one-pole 6dB/octave filter to the input."
    },
    "fl.complex.expr~": {
        "digest": "Calculates the result of a mathematical expression involving complex numbers."
    },
    "fl.expr~": {
        "digest": "Calculates the result of a mathematical expression."
    },
    "fl.filtertags~": {
        "digest": "Filters tagged frames using a set of specified tags."
    },
    "fl.tag~": {
        "digest": "Tags vectors with tags either in order to set parameters or for routing purposes."
    },
    "fl.untag~": {
        "digest": "Retrieves vectors from a tagged frame according to a specified set of tags."
    },
    "fl.combinetags~": {
        "digest": "Combines a number of tagged input frames into a single tagged output frame."
    }
}