{
    "fl.sort~": {
        "digest": "Sorts an input frame into ascending or descending order"
    },
    "fl.complex.sinh~": {
        "digest": "Calculates the hyperbolic sine of each complex value at the inputs"
    },
    "fl.shift~": {
        "digest": "Shifts samples within a frame"
    },
    "fl.tomax~": {
        "digest": "Turn frames into Max messages"
    },
    "fl.sink~": {
        "digest": "Outputs frames to the host environment as audio by overlap-adding into an output buffer"
    },
    "fl.copysign~": {
        "digest": "Copys the signs of the right input frame onto the magnitudes of the left input frame"
    },
    "fl.accumpos~": {
        "digest": "Finds the index where the cumulative sum reaches a specified percentage of its total"
    },
    "fl.framemin~": {
        "digest": "Calculates the minimum value of the input frame"
    },
    "fl.contextcontrol~": {
        "digest": "Controls a named context via Max messages."
    },
    "fl.greaterthaneq~": {
        "digest": "Compares input frames using a greater than or equal to operation (returns 1 or 0)"
    },
    "fl.complex.cos~": {
        "digest": "Calculates the cosine of each complex value at the inputs"
    },
    "fl.makestring~": {
        "digest": "Creates a tagged string by concatenating strings and numbers"
    },
    "fl.greaterthan~": {
        "digest": "Compares input frames using a greater than operation (returns 1 or 0)"
    },
    "fl.unpack~": {
        "digest": "Unpacks multistream input into individual streams"
    },
    "fl.complex.sin~": {
        "digest": "Calculates the sine of each complex value at the inputs"
    },
    "fl.complex.minus~": {
        "digest": "Subtracts complex values in the right input frame pair from those in the left pair"
    },
    "fl.or~": {
        "digest": "Calculates the logical or of the left and right input frame values"
    },
    "fl.exp2~": {
        "digest": "Calculates the exponent base 2 (2^x) of each value in the input frame"
    },
    "fl.complex.times~": {
        "digest": "Multiplies complex values in the two pairs of input frames"
    },
    "fl.convolve~": {
        "digest": "Convolves two inputs (either real or complex)"
    },
    "fl.centroid~": {
        "digest": "Calculates the centroid of the input frame"
    },
    "fl.medianfilter~": {
        "digest": "Applies a median or other specified percentiled filter to the input"
    },
    "fl.lookup~": {
        "digest": "Lookup values from one input using a table provided at another"
    },
    "fl.wrap~": {
        "digest": "Wraps the incoming frame into the range delimited by the two parameters"
    },
    "fl.complex.exp~": {
        "digest": "Calculates the exponent base e (e^x) of each complex value at the inputs"
    },
    "fl.multitaper~": {
        "digest": "Calculates a multitaper power (or amplitude) spectrum from a real input"
    },
    "fl.and~": {
        "digest": "Calculates the logical and of the left and right input frame values"
    },
    "fl.onepolezero~": {
        "digest": "Applies a one-pole with one-zero filter to the input"
    },
    "fl.percentile~": {
        "digest": "Calculates a specified percentile of the input frame (by default the 50th or median)"
    },
    "fl.firphase~": {
        "digest": "Transform FIR coefficients to preserve the amplitude spectrum but alter the phase"
    },
    "fl.asinh~": {
        "digest": "Calculates the hyperbolic arcsine of each value in the input frame"
    },
    "fl.times~": {
        "digest": "Multiplies values in the two input frames"
    },
    "fl.kurtosis~": {
        "digest": "Calculates the kurtosis of the input frame"
    },
    "fl.divide~": {
        "digest": "Divides the left input frame values by the right input frame values"
    },
    "fl.minus~": {
        "digest": "Subtracts the right input frame values from the left input frame values"
    },
    "fl.log~": {
        "digest": "Calculates the logarithm base e of each value in the input frame"
    },
    "fl.pow~": {
        "digest": "Raises left input frame values to the power of right input frame values"
    },
    "fl.erf~": {
        "digest": "Calculates the error function of each value in the input frame"
    },
    "fl.filtertags~": {
        "digest": "Filters tagged frames using a set of specified tags"
    },
    "fl.convert~": {
        "digest": "Converts the input vector according to a specified conversion"
    },
    "fl.maxpos~": {
        "digest": "Calculates the index of the maximum value of the input frame"
    },
    "fl.trace~": {
        "digest": "Outputs values from the input as audio, continuing the last value till a new frame arrives"
    },
    "fl.atan2~": {
        "digest": "Calculates the arctangent using two arguments (left operand is y, right operand is x)"
    },
    "fl.perblock~": {
        "digest": "Schedules one frame at the start of each host audio block"
    },
    "fl.complex.pow~": {
        "digest": "Raises left operand values to the power of right operand values (both complex)"
    },
    "fl.complex.log~": {
        "digest": "Calculates the logarithm base e of each complex value at the inputs"
    },
    "fl.nonzero~": {
        "digest": "Outputs the indices of input samples that are non-zero"
    },
    "fl.notequals~": {
        "digest": "Compares frame values for inequality (returns 1 or 0)"
    },
    "fl.timedelta~": {
        "digest": "Calculates the time interval between consecutive incoming frames"
    },
    "fl.read~": {
        "digest": "Reads from a specified host buffer given an input frame of positions"
    },
    "fl.stddev~": {
        "digest": "Calculates the standard deviation of the input frame"
    },
    "fl.streamid~": {
        "digest": "Outputs the stream id for each stream in a multistream connection"
    },
    "fl.lessthaneq~": {
        "digest": "Compares input frames using a less than or equal to operation (returns 1 or 0)"
    },
    "fl.once~": {
        "digest": "Schedules a single frame at the begining of time that lasts forever"
    },
    "fl.exp~": {
        "digest": "Calculates the exponent base e (e^x) of each value in the input frame"
    },
    "fl.audiotrigger~": {
        "digest": "Schedules frames based on non-zero audio input"
    },
    "fl.sin~": {
        "digest": "Calculates the sine (for arguments in radians) of each value in the input frame"
    },
    "fl.poltocar~": {
        "digest": "Converts from polar values at the inputs to cartesian values at the outputs"
    },
    "fl.lookupstring~": {
        "digest": "Lookup a specified string from an internally stored list of strings"
    },
    "fl.flatness~": {
        "digest": "Calculates the flatness (as a ratio) of the input frame"
    },
    "fl.log2~": {
        "digest": "Calculates the logarithm base 2 of each value in the input frame"
    },
    "fl.max~": {
        "digest": "Calculates the maximums of pairs of values in the two input frames"
    },
    "fl.asin~": {
        "digest": "Calculates the arcsine (in radians) of each value in the input frame"
    },
    "fl.timemedian~": {
        "digest": "Calculates the specified percentile per sample over the most recent frames"
    },
    "fl.correlate~": {
        "digest": "Correlates two inputs (either real or complex)"
    },
    "fl.skewness~": {
        "digest": "Calculates the skewness of the input frame"
    },
    "fl.interval~": {
        "digest": "Schedules frames at regular intervals set by the interval parameter"
    },
    "fl.acos~": {
        "digest": "Calculates the arccosine (in radians) of each value in the input frame"
    },
    "fl.cos~": {
        "digest": "Calculates the cosine (for arguments in radians) of each value in the input frame"
    },
    "fl.sinh~": {
        "digest": "Calculates the hyperbolic sine of each value in the input frame"
    },
    "fl.floor~": {
        "digest": "Calculates the floor function of each value in the input frame"
    },
    "fl.kernelsmooth~": {
        "digest": "Smooth an input based on a provided smoothing kernel"
    },
    "fl.join~": {
        "digest": "Concatenates all input frames into a single output frame"
    },
    "fl.uniform~": {
        "digest": "Generates frames in which all values are identical"
    },
    "fl.length~": {
        "digest": "Calculates the length of the input frame"
    },
    "fl.trunc~": {
        "digest": "Calculates the truncated value of each value in the input frame"
    },
    "fl.store~": {
        "digest": "Stores frames remotely for later recall"
    },
    "fl.log10~": {
        "digest": "Calculates the logarithm base 10 of each value in the input frame"
    },
    "fl.framedelta~": {
        "digest": "Outputs the deltas between consecutive frames"
    },
    "fl.spatial~": {
        "digest": "Generates multiplication factors for a number of speakers from an input coordinate triple"
    },
    "fl.constant~": {
        "digest": "Outputs a specified constant"
    },
    "fl.atanh~": {
        "digest": "Calculates the hyperbolic arctangent of each value in the input frame"
    },
    "fl.mean~": {
        "digest": "Calculates the mean of the input frame"
    },
    "fl.biquad~": {
        "digest": "Applies a biquad filter to the input"
    },
    "fl.lag~": {
        "digest": "Delay vector type input by a whole number of frames"
    },
    "fl.complex.cosh~": {
        "digest": "Calculates the hyperbolic cosine of each complex value at the inputs"
    },
    "fl.plus~": {
        "digest": "Adds values in the two input frames"
    },
    "fl.sqrt~": {
        "digest": "Calculates the square root of each value in the input frame"
    },
    "fl.timer~": {
        "digest": "Calculates the time elapsed between the each trigger input and the previous reset"
    },
    "fl.framemax~": {
        "digest": "Calculates the maximum value of the input frame"
    },
    "fl.rms~": {
        "digest": "Calculates the rms of the input frame"
    },
    "fl.frommax~": {
        "digest": "Turn Max messages into frames"
    },
    "fl.random~": {
        "digest": "Generates linearly distributed random values in the range [0-1]"
    },
    "fl.complex.expr~": {
        "digest": "Calculates the result of a mathematical expression involving complex numbers"
    },
    "fl.pack~": {
        "digest": "Packs multiple frame streams into a multistream output"
    },
    "fl.dispatch~": {
        "digest": "Dispatches multiple inputs dynamically to multiple outputs"
    },
    "fl.biquadcoeff~": {
        "digest": "Calculates biquad filter coefficients"
    },
    "fl.source~": {
        "digest": "Captures audio from the host environment and outputs the most recent values as frames"
    },
    "fl.modulo~": {
        "digest": "Calculates the left input frame values modulo the right input frame values"
    },
    "fl.pad~": {
        "digest": "Pads the input frame with a repeated specified value"
    },
    "fl.route~": {
        "digest": "Routes the input to one of a number of outputs"
    },
    "fl.fold~": {
        "digest": "Folds the incoming frame into the range delimited by the two parameters"
    },
    "fl.lessthan~": {
        "digest": "Compares input frames using a less than operation (returns 1 or 0)"
    },
    "fl.complex.log10~": {
        "digest": "Calculates the logarithm base 10 of each complex value at the inputs"
    },
    "fl.reverse~": {
        "digest": "Computes the reverse of the input frame"
    },
    "fl.complex.tanh~": {
        "digest": "Calculates the hyperbolic tangent of each complex value at the inputs"
    },
    "fl.complex.tan~": {
        "digest": "Calculates the tangent of each complex value at the inputs"
    },
    "fl.timemean~": {
        "digest": "Calculates the mean per sample over the most recent frames"
    },
    "fl.now~": {
        "digest": "Outputs the current time"
    },
    "fl.pattern~": {
        "digest": "Step through a frame of values (or pattern) one at a time"
    },
    "fl.diff~": {
        "digest": "Calculates the absolute differences between values in the two input frames"
    },
    "fl.gaussian~": {
        "digest": "Generates frames of normally distributed random values"
    },
    "fl.complex.conj~": {
        "digest": "Calculates the complex conjugate of each complex value at the inputs"
    },
    "fl.acosh~": {
        "digest": "Calculates the hyperbolic arccosine of each value in the input frame"
    },
    "fl.map~": {
        "digest": "Maps values from input to output via a specified scaling"
    },
    "fl.makewindow~": {
        "digest": "Generates a specified window function across each output frame"
    },
    "fl.select~": {
        "digest": "Selects output from a number of inputs"
    },
    "fl.tan~": {
        "digest": "Calculates the tangent (for arguments in radians) of each value in the input frame"
    },
    "fl.sum~": {
        "digest": "Calculates the sum of the input frame"
    },
    "fl.equals~": {
        "digest": "Compares frame values for equality (returns 1 or 0)"
    },
    "fl.not~": {
        "digest": "Calculates the logical not of each value in the input frame"
    },
    "fl.atan~": {
        "digest": "Calculates the arctangent (in radians) of each value in the input frame"
    },
    "fl.clip~": {
        "digest": "Clips the incoming frame to the range delimited by the two parameters"
    },
    "fl.tanh~": {
        "digest": "Calculates the hyperbolic tangent of each value in the input frame"
    },
    "fl.nanfilter~": {
        "digest": "Filter NaNs from the input either by replacing or by removing them"
    },
    "fl.ramp~": {
        "digest": "Generates a linear ramp across each output frame"
    },
    "fl.tag~": {
        "digest": "Tags vectors with tags either in order to set parameters or for routing purposes"
    },
    "fl.timestddev~": {
        "digest": "Calculates the standard deviation per sample over the most recent frames"
    },
    "fl.fft~": {
        "digest": "Calculate the real or complex Fast Fourier Transform of the input(s)"
    },
    "fl.geomean~": {
        "digest": "Calculates the geometric mean of the input frame"
    },
    "fl.ifft~": {
        "digest": "Calculate the real or complex inverse Fast Fourier Transform of the inputs (real and imaginary)"
    },
    "fl.erfc~": {
        "digest": "Calculates the complimentary error function of each value in the input frame"
    },
    "fl.split~": {
        "digest": "Splits input frames into two frames, given a specified split point"
    },
    "fl.movingaverage~": {
        "digest": "Calculates per sample moving averages and standard deviations"
    },
    "fl.complex.divide~": {
        "digest": "Divides complex values in the left pair of input frames by those in the right pair"
    },
    "fl.abs~": {
        "digest": "Calculates the absolute value of each value in the input frame"
    },
    "fl.svf~": {
        "digest": "Applies a state variable filter to the input"
    },
    "fl.subframe~": {
        "digest": "Output a specified segment of an input frame"
    },
    "fl.minpos~": {
        "digest": "Calculates the index of the minimum value of the input frame"
    },
    "fl.hypot~": {
        "digest": "Calculates the length of a hypotenuse given the two operands as the other lengths"
    },
    "fl.onepole~": {
        "digest": "Applies  a one-pole 6dB/octave filter to the input"
    },
    "fl.untag~": {
        "digest": "Retrieves vectors from a tagged frame according to a specified set of tags"
    },
    "fl.product~": {
        "digest": "Calculates the product of the input frame"
    },
    "fl.crest~": {
        "digest": "Calculates the crest factor of the input frame"
    },
    "fl.chop~": {
        "digest": "Chops input frames into equally sized output frames of a specified size"
    },
    "fl.register~": {
        "digest": "Store and recall frames locally"
    },
    "fl.min~": {
        "digest": "Calculates the minimums of pairs of values in the two input frames"
    },
    "fl.round~": {
        "digest": "Calculates the rounded value of each value in the input frame"
    },
    "fl.expr~": {
        "digest": "Calculates the result of a mathematical expression"
    },
    "fl.peaks~": {
        "digest": "Finds peaks in the input frame"
    },
    "fl.cbrt~": {
        "digest": "Calculates the cube root of each value in the input frame"
    },
    "fl.complex.plus~": {
        "digest": "Adds complex values in the two pairs of input frames"
    },
    "fl.complex.sqrt~": {
        "digest": "Calculates the square root of each complex value at the inputs"
    },
    "fl.ticks~": {
        "digest": "Counts incoming frames"
    },
    "fl.cartopol~": {
        "digest": "Converts from cartesian values at the inputs to polar values at the outputs"
    },
    "fl.prioritise~": {
        "digest": "Apply a fixed priority ranking to synchronous input frames"
    },
    "fl.cosh~": {
        "digest": "Calculates the hyperbolic cosine of each value in the input frame"
    },
    "fl.spread~": {
        "digest": "Calculates the spread of the input frame"
    },
    "fl.combinetags~": {
        "digest": "Combines a number of tagged input frames into a single tagged output frame"
    },
    "fl.ceil~": {
        "digest": "Calculates the ceiling function of each value in the input frame"
    },
    "fl.chain~": {
        "digest": "Schedules frames in the future at times specified times in the input frame"
    },
    "fl.info~": {
        "digest": "Outputs the sample rate, number of channels and length of a specified buffer"
    },
    "fl.recall~": {
        "digest": "Recall a remotely stored frame for use"
    },
    "fl.window~": {
        "digest": "Multiplies the input frame by a specified window"
    },
    "fl.samplerate~": {
        "digest": "Convert or output values based on the sample rate"
    }
}