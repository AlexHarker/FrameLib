{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww15580\viewh11360\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs24 \cf0 \

\b Goals
\b0 \
\
- Speed\
- Good re-use (for cache speed)\
- Good compactness (to aid contraction)\
- O(1) complexity\
- Expanding memory pool\
	- Multiple smaller pools addressed as composite\
- Contracting memory pool\
	- Can identify when pools are fully free and release to main memory\
\
Local Level\
	- Free pools\
\
Global Level\
	- Larger Pools from main memory \
\
\

\b ON INDIVIDUAL MEMORY CALL\

\b0 \

\b DONE	
\b0 1 - Check local
\b  level free pools
\b0  (all other operations must be thread safe - this is currently thread local)\
\

\b DONE	
\b0 2 - If local pools fail check 
\b pre-allocated pools
\b0  with proper allocation (removing freed pools from scheduled deletion if necessary)\
\

\b DONE 	
\b0 3 - If pre-allocated global pools fail\

\b DONE
\b0 	a - check if 
\b previously scheduled (and sufficient) allocation
\b0  has completed or a free pool is available\

\b DONE	
\b0 	b - if not, 
\b call to main memory
\b0  - if large allocate block of nearby size, otherwise add fixed size block\

\b DONE	
\b0 	c - 
\b add new pool
\b0  to pre-allocated pools 
\b allocating from there
\b0 \
\
4 - check overall memory usage if near capacity (and schedule new memory if not)\
	a - 
\b remove blocks scheduled to be freed
\b0  if available or \
	b - 
\b schedule fixed memory block to be allocated in another thread
\b0  if none is pending (joining next time it is needed)\
\

\b ONCE PER AUDIO CALL/DSP QUEUE EXIT
\b0 \
\

\b DONE 
\b0 5 - Check for empty blocks and schedule deletion\
\

\i\b question
\b0  - how do we make these searches low complexity/non-linear?\

\i0 \
Possible further heuristics/considerations\
\
\ul ADDING\ulnone \
A - add large amounts so that we never expect to need more than 1 per call\
B - look at growth rates?\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \ul \ulc0 DELETING\ulnone \
A - only ever delete one per *time*\
B - allow more than one deletion (complexity issue)\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\i\b \cf0 question
\b0  - how do we minimise thread synchronisation (and ideally make the audio thread non-blocking)\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\i0 \cf0 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\b \cf0 CALLS
\b0 \
\
localAllocate\
globalAllocate\
	- preAllocated\
	- joinScheduled\
	- addPool\
globalService\
	- scheduleAdd (+ associated thread specific add)\
	- scheduleDelete (+ associated thread specific delete)\
\
	\
Threading updates:\
\
Additional processes:\
\
1 - check for memory near full (on every main allocation) and schedule new pool\
2 - if memory allocation fails try these in order:\
	- pick up scheduled new memory (waiting if necessary - simply spinning on the pointer being null)\
	- pick up scheduled free memory\
	- allocate directly\
3 - schedule memory to be freed, never do it directly\
\
We require:\
\
1 - A thread we can \
	- create (with main loop function)		(main allocator constructor)\
	- destroy							(main allocator deconstructor)\
	- signal (semaphore)					(alloc/prune)\
\
2 - Pointers that we can swap in a threadsafe manner (with null values only)}